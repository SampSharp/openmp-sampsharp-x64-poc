using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Dynamic;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp;
using SashManaged.SourceGenerator.Marshalling;
using SashManaged.SourceGenerator.SyntaxFactories;

using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using static SashManaged.SourceGenerator.SyntaxFactories.TypeSyntaxFactory;
using static SashManaged.SourceGenerator.SyntaxFactories.HelperSyntaxFactory;
using static SashManaged.SourceGenerator.SyntaxFactories.StatementFactory;

namespace SashManaged.SourceGenerator;

/// <summary>
/// This source generator generates the marshalling interop methods for open.mp API structs. The generator generates the
/// following:
/// <list type="bullet">
///     <item>Implementation of the IPointer interface</item>
///     <item>Implementation of the IEquatable{self} interface</item>
///     <item>P/Invoke every partial method in the interface with marshalling of every parameter and return value</item>
///     <item>For every "implementing" interface specified in the CodeGen attribute generate the following:
///        <list type="bullet">
///             <item>Implementation of the IEquatable{other} interface</item>
///             <item>Pass-through implementations of all methods in the implementing interface</item>
///         </list>
///     </item>
/// </list>
/// </summary>
[Generator]
public class OpenMpApiCodeGenV2 : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var attributedStructs = context.SyntaxProvider.ForAttributeWithMetadataName(
                Constants.ApiAttributeFQN,
                static (s, _) => s is StructDeclarationSyntax str && str.IsPartial(), 
                static (ctx, ct) => GetStructDeclaration(ctx, ct))
            .Where(x => x is not null);

        context.RegisterSourceOutput(attributedStructs, (ctx, info) =>
        {
            var modifiers = info!.Syntax.Modifiers;
            modifiers = modifiers.Insert(modifiers.IndexOf(SyntaxKind.PartialKeyword), Token(SyntaxKind.UnsafeKeyword));

            var structDeclaration = StructDeclaration(info!.Syntax.Identifier)
                .WithModifiers(modifiers)
                .WithMembers(GenerateStructMembers(info))
                .WithBaseList(
                    BaseList(
                        SeparatedList<BaseTypeSyntax>(
                            GetBaseTypes(info))))
                .WithAttributeLists(
                    List(
                        new []{
                            AttributeFactory.GeneratedCode(),
                            AttributeFactory.SkipLocalsInit()
                        }));

            var unit = CompilationUnit()
                .AddMembers(NamespaceDeclaration(ParseName(info.Symbol.ContainingNamespace.ToDisplayString()))
                    .AddMembers(structDeclaration))
                .WithLeadingTrivia(
                    TriviaFactory.AutoGeneratedComment());

            var sourceText = unit.NormalizeWhitespace(elasticTrivia: true)
                .GetText(Encoding.UTF8);

            ctx.AddSource($"{info.Symbol.Name}.g.cs", sourceText);
        });
    }

    /// <summary>
    /// Returns the base types for the generated struct implementation.
    /// </summary>
    private static IEnumerable<SimpleBaseTypeSyntax> GetBaseTypes(StructStubGenerationContext ctx)
    {
        var result = ctx.ImplementingTypes.Select(x => 
                SimpleBaseType(
                    GenericName(
                            IdentifierGlobal(Constants.IEquatableFQN))
                        .WithTypeArgumentList(
                            TypeArgumentList(
                                SingletonSeparatedList<TypeSyntax>(
                                    IdentifierNameGlobal(x))))))
            .Concat([
                SimpleBaseType(
                    GenericName(
                            IdentifierGlobal(Constants.IEquatableFQN))
                        .WithTypeArgumentList(
                            TypeArgumentList(
                                SingletonSeparatedList<TypeSyntax>(
                                    IdentifierName(ctx.Symbol.Name))))),
                SimpleBaseType(
                    IdentifierNameGlobal(Constants.PointerFQN))
            ]);
        
        if (ctx.IsComponent)
        {
            result = result.Concat([
                SimpleBaseType(
                    GenericName(
                            IdentifierGlobal(Constants.ComponentInterfaceFQN))
                        .WithTypeArgumentList(
                            TypeArgumentList(
                                SingletonSeparatedList<TypeSyntax>(
                                    IdentifierName(ctx.Symbol.Name)))))
            ]);
        }

        if (ctx.IsExtension)
        {
            result = result.Concat([
                SimpleBaseType(
                    GenericName(
                            IdentifierGlobal(Constants.ExtensionInterfaceFQN))
                        .WithTypeArgumentList(
                            TypeArgumentList(
                                SingletonSeparatedList<TypeSyntax>(
                                    IdentifierName(ctx.Symbol.Name)))))
            ]);
        }

        return result;
    }

    /// <summary>
    /// Returns the members for the struct implementation.
    /// </summary>
    private static SyntaxList<MemberDeclarationSyntax> GenerateStructMembers(StructStubGenerationContext ctx)
    {
        return List(
            GenerateCommonStructMembers(ctx)
                .Concat(GenerateImplementingTypeMembers(ctx))
                .Concat(
                    ctx.Methods.Select(GenerateNativeMethod)
                        .Where(x => x != null)));
    }
    
    /// <summary>
    /// Returns members for implementing the types specified in the CodeGen attribute.
    /// </summary>
    private static SyntaxList<MemberDeclarationSyntax> GenerateImplementingTypeMembers(StructStubGenerationContext ctx)
    {
        var result = List<MemberDeclarationSyntax>();

        foreach (var implementingType in ctx.ImplementingTypes)
        {
            var implementingMethods = implementingType.GetMembers()
                .OfType<IMethodSymbol>()
                .Where(x => !x.IsStatic && x.MethodKind == MethodKind.Ordinary && x.Name != "Equals");

            foreach (var implementingMethod in implementingMethods)
            {
                var method = MethodDeclaration(
                        TypeNameGlobal(implementingMethod), 
                        implementingMethod.Name)
                    .WithParameterList(ToParameterListSyntax(implementingMethod.Parameters))
                    .WithModifiers(
                        TokenList(
                            Token(SyntaxKind.PublicKeyword)));

                SimpleNameSyntax memberName = IdentifierName(implementingMethod.Name);
                if (implementingMethod.TypeParameters.Length > 0)
                {
                    method = method.WithTypeParameterList(
                        TypeParameterList(
                            SeparatedList(
                                implementingMethod.TypeParameters.Select(x => TypeParameter(x.Name)))));

                    memberName = GenericName(
                            Identifier(implementingMethod.Name))
                        .WithTypeArgumentList(
                            TypeArgumentList(
                                SeparatedList<TypeSyntax>(
                                    implementingMethod.TypeParameters.Select(x => IdentifierName(x.Name)))));
                }

                method = method.WithConstraintClauses(
                    List(
                        implementingMethod.TypeParameters
                            .Select(x => TypeParameterConstraintClause(IdentifierName(x.Name))
                                .WithConstraints(
                                    SeparatedList(
                                        x.ConstraintTypes.Select(y => (TypeParameterConstraintSyntax)ToTypeConstraint(y)))))));    

                var invocation =  
                    InvocationExpression(
                        MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            ObjectCreationExpression(
                                    IdentifierNameGlobal(implementingType))
                                .WithArgumentList(
                                    ArgumentList(
                                        SingletonSeparatedList(
                                            Argument(
                                                IdentifierName("_handle"))))),
                            memberName))
                        .WithArgumentList(
                            ArgumentList(
                                SeparatedList(
                                    implementingMethod.Parameters.Select(GetArgumentForParameter))));
                
                if (implementingMethod.ReturnsVoid)
                {
                    method = method.WithBody(
                        Block(
                            SingletonList(
                                ExpressionStatement(invocation))));
                }
                else if (implementingMethod.ReturnsByRef || implementingMethod.ReturnsByRefReadonly)
                {
                    method = method.WithBody(
                        Block(
                            SingletonList(
                                ReturnStatement(
                                    RefExpression(invocation)))));
                }
                else
                {
                    method = method.WithBody(
                        Block(
                            SingletonList(
                                ReturnStatement(invocation))));
                }

                result = result.Add(method);
            }
        }

        if (ctx.IsComponent)
        {
            result = result.Add(CreateFromHandleMethod(ctx, Constants.ComponentInterfaceFQN));
        }
        if (ctx.IsExtension)
        {
            result = result.Add(CreateFromHandleMethod(ctx, Constants.ExtensionInterfaceFQN));
        }
        return result;
    }

    private static TypeConstraintSyntax ToTypeConstraint(ITypeSymbol typeSymbol)
    {
        var typeSyntax = ParseTypeName(typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));

        return TypeConstraint(typeSyntax);
    }

    /// <summary>
    /// Returns an explicit interface implementation method declaration for the FromHandle method for the specified
    /// interface.
    /// </summary>
    private static MethodDeclarationSyntax CreateFromHandleMethod(StructStubGenerationContext ctx, string genericInterfaceFQN)
    {
        return MethodDeclaration(
                IdentifierName(ctx.Symbol.Name),
                Identifier("FromHandle"))
            .WithModifiers(
                TokenList(
                    Token(SyntaxKind.StaticKeyword)))
            .WithExplicitInterfaceSpecifier(
                ExplicitInterfaceSpecifier(
                    GenericName(
                            IdentifierGlobal(genericInterfaceFQN))
                        .WithTypeArgumentList(
                            TypeArgumentList(
                                SingletonSeparatedList<TypeSyntax>(
                                    IdentifierName(ctx.Symbol.Name))))))
            .WithParameterList(
                ParameterList(
                    SingletonSeparatedList(
                        Parameter(
                                Identifier("handle"))
                            .WithType(
                                ParseTypeName("nint")))))
            .WithBody(
                Block(
                    SingletonList<StatementSyntax>(
                        ReturnStatement(
                            ObjectCreationExpression(
                                    IdentifierName(ctx.Symbol.Name))
                                .WithArgumentList(
                                    ArgumentList(
                                        SingletonSeparatedList(
                                            Argument(
                                                IdentifierName("handle")))))))));
    }

    /// <summary>
    /// Returns members for the struct implementation that are common to all structs and equality members for all
    /// implementing types.
    /// </summary>
    private static IEnumerable<MemberDeclarationSyntax> GenerateCommonStructMembers(StructStubGenerationContext ctx)
    {
        // private readonly field _handle;
        var nintType = ParseTypeName("nint");
        yield return FieldDeclaration(VariableDeclaration(nintType, SingletonSeparatedList(VariableDeclarator("_handle"))))
            .WithModifiers(TokenList(Token(SyntaxKind.PrivateKeyword), Token(SyntaxKind.ReadOnlyKeyword)));

        // .ctor(nint handle)
        yield return ConstructorDeclaration(Identifier(ctx.Symbol.Name))
            .WithParameterList(ParameterList(
                SingletonSeparatedList(
                Parameter(Identifier("handle")).WithType(nintType)
                )))
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
            .WithBody(Block(
                SingletonList(
                    ExpressionStatement(
                        AssignmentExpression(
                            SyntaxKind.SimpleAssignmentExpression, 
                            IdentifierName("_handle"),
                            IdentifierName("handle"))))));

        // public nint Handle => _handle;
        yield return PropertyDeclaration(nintType, "Handle")
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
            .WithExpressionBody(ArrowExpressionClause(IdentifierName("_handle")))
            .WithSemicolonToken(Token(SyntaxKind.SemicolonToken));

        // public override bool Equals(object obj)
        yield return MethodDeclaration(
            PredefinedType(Token(SyntaxKind.BoolKeyword)),
            Identifier("Equals"))
        .WithModifiers(
            TokenList(
                Token(SyntaxKind.PublicKeyword),
                Token(SyntaxKind.OverrideKeyword)
            ))
        .WithParameterList(
            ParameterList(
                SingletonSeparatedList(
                    Parameter(
                        Identifier("obj"))
                    .WithType(
                            PredefinedType(Token(SyntaxKind.ObjectKeyword))))))
        .WithBody(
            Block(
                IfStatement(
                    BinaryExpression(
                        SyntaxKind.LogicalAndExpression,
                        IsPatternExpression(
                            IdentifierName("obj"),
                            ConstantPattern(
                                LiteralExpression(SyntaxKind.NullLiteralExpression))),
                        BinaryExpression(
                            SyntaxKind.EqualsExpression,
                            IdentifierName("Handle"),
                            MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                ParseTypeName("nint"),
                                IdentifierName("Zero")))),
                    Block(
                        SingletonList<StatementSyntax>(
                            ReturnStatement(
                                LiteralExpression(SyntaxKind.TrueLiteralExpression))))),
                ReturnStatement(
                    BinaryExpression(
                        SyntaxKind.LogicalAndExpression,
                        IsPatternExpression(
                            IdentifierName("obj"),
                            DeclarationPattern(
                                IdentifierNameGlobal(Constants.PointerFQN),
                                SingleVariableDesignation(
                                    Identifier("other")))),
                        InvocationExpression(
                            IdentifierName("Equals"))
                        .WithArgumentList(
                            ArgumentList(
                                SingletonSeparatedList(
                                    Argument(IdentifierName("other")))))))));

        // public bool Equals(IPointer other)
        yield return MethodDeclaration(
                PredefinedType(
                    Token(SyntaxKind.BoolKeyword)),
                Identifier("Equals"))
            .WithModifiers(
                TokenList(
                    Token(SyntaxKind.PublicKeyword)))
            .WithParameterList(
                ParameterList(
                    SingletonSeparatedList(
                        Parameter(Identifier("other"))
                            .WithType(IdentifierName("IPointer")))))
            .WithBody(
                Block(
                    SingletonList<StatementSyntax>(
                        ReturnStatement(
                            BinaryExpression(
                                SyntaxKind.EqualsExpression,
                                IdentifierName("_handle"),
                                ParenthesizedExpression(
                                    BinaryExpression(
                                        SyntaxKind.CoalesceExpression,
                                        ConditionalAccessExpression(
                                            IdentifierName("other"),
                                            MemberBindingExpression(
                                                IdentifierName("Handle"))),
                                        MemberAccessExpression(
                                            SyntaxKind.SimpleMemberAccessExpression,
                                            IdentifierName("nint"),
                                            IdentifierName("Zero")))))))));

        // public override int GetHashCode()
        yield return MethodDeclaration(
                PredefinedType(
                    Token(SyntaxKind.IntKeyword)),
                Identifier("GetHashCode"))
            .WithModifiers(
                TokenList(
                    Token(SyntaxKind.PublicKeyword),
                    Token(SyntaxKind.OverrideKeyword)
                ))
            .WithBody(
                Block(
                    SingletonList<StatementSyntax>(
                        ReturnStatement(
                            InvocationExpression(
                                MemberAccessExpression(
                                    SyntaxKind.SimpleMemberAccessExpression,
                                    IdentifierName("_handle"),
                                    IdentifierName("GetHashCode")))))));

        //type == object
        yield return CreateOperator(
                SyntaxKind.EqualsEqualsToken,
                IdentifierName(ctx.Symbol.Name), 
                PredefinedType(Token(SyntaxKind.ObjectKeyword)),
                CreateEqualsInvocationLhsRhs(false)
            );

        // type != object
        yield return CreateOperator(
                SyntaxKind.ExclamationEqualsToken,
                IdentifierName(ctx.Symbol.Name), 
                PredefinedType(Token(SyntaxKind.ObjectKeyword)),
                CreateEqualsInvocationLhsRhs(true)
            );

        // object == type
        yield return CreateOperator(
                SyntaxKind.EqualsEqualsToken,
                PredefinedType(Token(SyntaxKind.ObjectKeyword)),
                IdentifierName(ctx.Symbol.Name),
                CreateEqualsInvocationRhsLhs(false)
            );
        
        // object != type
        yield return CreateOperator(
                SyntaxKind.ExclamationEqualsToken,
                PredefinedType(Token(SyntaxKind.ObjectKeyword)),
                IdentifierName(ctx.Symbol.Name),
                CreateEqualsInvocationRhsLhs(true)
            );

        // bool Equals(type other)
        yield return CreateEqualsMethod(IdentifierName(ctx.Symbol.Name));
        
        //type == type
        yield return CreateOperator(
                SyntaxKind.EqualsEqualsToken,
                IdentifierName(ctx.Symbol.Name), 
                IdentifierName(ctx.Symbol.Name),
                CreateEqualsInvocationLhsRhs(false)
            );

        // type != type
        yield return CreateOperator(
                SyntaxKind.ExclamationEqualsToken,
                IdentifierName(ctx.Symbol.Name), 
                IdentifierName(ctx.Symbol.Name),
                CreateEqualsInvocationLhsRhs(true)
            );

        // TODO members for inheritance with depth > 1
        foreach (var type in ctx.ImplementingTypes)
        {
            var implName = IdentifierNameGlobal(type);

            // public bool Equals(impl other)
            yield return CreateEqualsMethod(implName);

            //type == impl
            yield return CreateOperator(
                    SyntaxKind.EqualsEqualsToken,
                    IdentifierName(ctx.Symbol.Name), 
                    implName,
                    CreateEqualsInvocationLhsRhs(false)
                );

            // type != impl
            yield return CreateOperator(
                    SyntaxKind.ExclamationEqualsToken,
                    IdentifierName(ctx.Symbol.Name), 
                    implName,
                    CreateEqualsInvocationLhsRhs(true)
                );

            // impl == type
            yield return CreateOperator(
                    SyntaxKind.EqualsEqualsToken,
                    implName, 
                    IdentifierName(ctx.Symbol.Name),
                    CreateEqualsInvocationRhsLhs(false)
                );
        
            // impl != type
            yield return CreateOperator(
                    SyntaxKind.ExclamationEqualsToken,
                    implName, 
                    IdentifierName(ctx.Symbol.Name),
                    CreateEqualsInvocationRhsLhs(true)
                );

            yield return ConversionOperatorDeclaration(
                Token(SyntaxKind.ImplicitKeyword),
                implName)
            .WithModifiers(
                TokenList(
                    Token(SyntaxKind.PublicKeyword),
                    Token(SyntaxKind.StaticKeyword)))
            .WithParameterList(
                ParameterList(
                    SingletonSeparatedList(
                        Parameter(
                            Identifier("value"))
                        .WithType(
                            IdentifierName(ctx.Symbol.Name)))))
            .WithBody(
                Block(
                    SingletonList<StatementSyntax>(
                        ReturnStatement(
                            ObjectCreationExpression(
                                implName)
                            .WithArgumentList(
                                ArgumentList(
                                    SingletonSeparatedList(
                                        Argument(
                                            MemberAccessExpression(
                                                SyntaxKind.SimpleMemberAccessExpression,
                                                IdentifierName("value"),
                                                IdentifierName("Handle"))))))))));

            yield return ConversionOperatorDeclaration(
                Token(SyntaxKind.ExplicitKeyword),
                IdentifierName(ctx.Symbol.Name))
            .WithModifiers(
                TokenList(Token(SyntaxKind.PublicKeyword),
                    Token(SyntaxKind.StaticKeyword)))
            .WithParameterList(
                ParameterList(
                    SingletonSeparatedList(
                        Parameter(
                            Identifier("value"))
                        .WithType(
                            implName))))
            .WithBody(
                Block(
                    SingletonList<StatementSyntax>(
                        ReturnStatement(
                            ObjectCreationExpression(
                                IdentifierName(ctx.Symbol.Name))
                            .WithArgumentList(
                                ArgumentList(
                                    SingletonSeparatedList(
                                        Argument(
                                            MemberAccessExpression(
                                                SyntaxKind.SimpleMemberAccessExpression,
                                                IdentifierName("value"),
                                                IdentifierName("Handle"))))))))));
        }
    }

    /// <summary>
    /// Returns a method declaration for the Equals method comparing the current type with the specified type.
    /// </summary>
    private static MethodDeclarationSyntax CreateEqualsMethod(TypeSyntax typeName)
    {
        return MethodDeclaration(
                PredefinedType(
                    Token(SyntaxKind.BoolKeyword)),
                Identifier("Equals"))
            .WithModifiers(
                TokenList(
                    Token(SyntaxKind.PublicKeyword)))
            .WithParameterList(
                ParameterList(
                    SingletonSeparatedList(
                        Parameter(Identifier("other"))
                            .WithType(typeName))))
            .WithBody(
                Block(
                    SingletonList<StatementSyntax>(
                        ReturnStatement(
                            BinaryExpression(
                                SyntaxKind.EqualsExpression,
                                IdentifierName("Handle"),
                                MemberAccessExpression(
                                    SyntaxKind.SimpleMemberAccessExpression,
                                    IdentifierName("other"),
                                    IdentifierName("Handle")))))));
    }

    /// <summary>
    /// Returns a method declaration for a native method including marshalling of parameters and return value.
    /// </summary>
    private static MemberDeclarationSyntax GenerateNativeMethod(MethodStubGenerationContext ctx)
    {
        var invocation = CreateInvocation(ctx);
        
        // Extern P/Invoke
        var externReturnType = ctx.ReturnMarshallerShape?.GetNativeType() ?? 
                               TypeNameGlobal(ctx.Symbol.ReturnType);

        if(ctx.ReturnsByRef)
        {
            externReturnType = ctx.RequiresMarshalling
                ? PointerType(externReturnType)
                : RefType(externReturnType);
        }

        var externFunction = GenerateExternFunction(ctx, externReturnType);

        invocation = invocation.WithStatements(invocation.Statements.Add(externFunction));
     
        return MethodDeclaration(TypeNameGlobal(ctx.Symbol), ctx.Declaration.Identifier)
            .WithModifiers(ctx.Declaration.Modifiers)
            .WithParameterList(ToParameterListSyntax(ctx.Symbol.Parameters))
            .WithBody(invocation);
    }

    /// <summary>
    /// Returns a block with the invocation of the native method including marshalling of parameters and return value.
    /// </summary>
    private static BlockSyntax CreateInvocation(MethodStubGenerationContext ctx)
    {
        return ctx.RequiresMarshalling 
            ? CreateInvocationWithMarshalling(ctx)
            : CreateInvocationWithoutMarshalling(ctx);
    }

    private static BlockSyntax CreateInvocationWithoutMarshalling(MethodStubGenerationContext ctx)
    {
        ExpressionSyntax invoke = InvocationExpression(IdentifierName("__PInvoke"))
            .WithArgumentList(
                ArgumentList(
                    SingletonSeparatedList(Argument(IdentifierName("_handle")))
                        .AddRange(
                            ctx.Parameters.Select(GetArgumentForParameter)
                        )
                )
            );

        if (ctx.Symbol.ReturnsVoid)
        {
            return Block(ExpressionStatement(invoke));
        }
            
        if (ctx.Symbol.ReturnsByRef || ctx.Symbol.ReturnsByRefReadonly)
        {
            invoke = RefExpression(invoke);
        }

        return Block(ReturnStatement(invoke));
    }

    private static BlockSyntax CreateInvocationWithMarshalling(MethodStubGenerationContext ctx)
    {
        ExpressionSyntax invoke = 
            InvocationExpression(IdentifierName("__PInvoke"))
                .WithArgumentList(
                    ArgumentList(
                        SingletonSeparatedList(
                                Argument(IdentifierName("_handle")))
                            .AddRange(
                                ctx.Parameters.Select(GetArgumentForParameter))));
        
        if (!ctx.Symbol.ReturnsVoid)
        {
            invoke = 
                AssignmentExpression(
                    SyntaxKind.SimpleAssignmentExpression, 
                    IdentifierName(ctx.ReturnMarshallerShape == null ? "__retVal" : "__retVal_native"), 
                    invoke);
        }

        // The generated method consists of the following content:
        //
        // LocalsInit - Generate locals for marshalled types and return value.
        // Setup - Perform required setup.
        // try
        // {
        //   Marshal - Convert managed data to native data.
        //   {
        //     PinnedMarshal - Convert managed data to native data that requires the managed data to be pinned.
        //     p/invoke 
        //   }
        //   [[__invokeSucceeded = true;]]
        //   NotifyForSuccessfulInvoke - Keep alive any managed objects that need to stay alive across the call.
        //   UnmarshalCapture - Capture the native data into marshaller instances in case conversion to managed data throws an exception.
        //   Unmarshal - Convert native data to managed data.
        // }
        // finally
        // {
        //   if (__invokeSucceeded)
        //   {
        //      GuaranteedUnmarshal - Convert native data to managed data even in the case of an exception during the non-cleanup phases.
        //      CleanupCalleeAllocated - Perform cleanup of callee allocated resources.
        //   }
        //   CleanupCallerAllocated - Perform cleanup of caller allocated resources.
        // }
        //
        // return: retVal
        //
        // NOTES:
        // - design doc: https://github.com/dotnet/runtime/blob/main/docs/design/libraries/LibraryImportGenerator/UserTypeMarshallingV2.md
        // - we're supporting Default, ManagedToUnmanagedIn, ManagedToUnmanagedOut, ManagedToUnmanagedRef
        // - not implementing element marshalling (arrays) at the moment.

        // collect all marshalling steps
        var setup = Step(ctx, MarshallingCodeGenDocumentation.COMMENT_SETUP, (p, m) => m.Setup(p), ctx.ReturnMarshallerShape?.Setup(null) ?? default);
        var marshal = Step(ctx, MarshallingCodeGenDocumentation.COMMENT_MARSHAL, (p, m) => m.Marshal(p), ctx.ReturnMarshallerShape?.Marshal(null) ?? default);
        var pinnedMarshal = Step(ctx, MarshallingCodeGenDocumentation.COMMENT_PINNED_MARSHAL, (p, m) => m.PinnedMarshal(p), ctx.ReturnMarshallerShape?.PinnedMarshal(null) ?? default);
        var pin = Step(ctx, MarshallingCodeGenDocumentation.COMMENT_PIN, (p, m) => m.Pin(p));
        var notify = Step(ctx, MarshallingCodeGenDocumentation.COMMENT_NOTIFY, (p, m) => m.NotifyForSuccessfulInvoke(p), ctx.ReturnMarshallerShape?.NotifyForSuccessfulInvoke(null) ?? default);
        var unmarshalCapture = Step(ctx, MarshallingCodeGenDocumentation.COMMENT_UNMARSHAL_CAPTURE, (p, m) => m.UnmarshalCapture(p), ctx.ReturnMarshallerShape?.UnmarshalCapture(null) ?? default);
        var unmarshal = Step(ctx, MarshallingCodeGenDocumentation.COMMENT_UNMARSHAL, (p, m) => m.Unmarshal(p), ctx.ReturnMarshallerShape?.Unmarshal(null) ?? default);
        var guaranteedUnmarshal = Step(ctx, MarshallingCodeGenDocumentation.COMMENT_GUARANTEED_UNMARSHAL, (p, m) => m.GuaranteedUnmarshal(p), ctx.ReturnMarshallerShape?.GuaranteedUnmarshal(null) ?? default);
        var cleanupCallee = Step(ctx, MarshallingCodeGenDocumentation.COMMENT_CLEANUP_CALLEE, (p, m) => m.CleanupCalleeAllocated(p), ctx.ReturnMarshallerShape?.CleanupCalleeAllocated(null) ?? default);
        var cleanupCaller = Step(ctx, MarshallingCodeGenDocumentation.COMMENT_CLEANUP_CALLER, (p, m) => m.CleanupCallerAllocated(p), ctx.ReturnMarshallerShape?.CleanupCallerAllocated(null) ?? default);
        
        // init locals
        var statements = Step(ctx, null, (p, m) =>
        {
            if (!m.RequiresLocal)
            {
                return new SyntaxList<StatementSyntax>();
            }

            var identifier = $"__{p.Name}_native";

            return SingletonList<StatementSyntax>(CreateLocalDeclarationWithDefaultValue(m.GetNativeType(), identifier));
        });

        if (!ctx.Symbol.ReturnsVoid)
        {
            var returnType = TypeNameGlobal(ctx.Symbol.ReturnType);
            
            if (ctx.ReturnsByRef)
            {
                returnType = PointerType(returnType);
            }

            statements = statements.Add(CreateLocalDeclarationWithDefaultValue(returnType, "__retVal"));
            
            if (ctx.ReturnMarshallerShape != null)
            {
                var nativeType = ctx.ReturnMarshallerShape.GetNativeType();
                statements = statements.Add(CreateLocalDeclarationWithDefaultValue(nativeType, "__retVal_native"));
            }
        }

        // if callee cleanup is required, we need to keep track of invocation success
        if (cleanupCallee.Count > 0 || guaranteedUnmarshal.Count > 0)
        {
            statements = statements.Add(
                CreateLocalDeclarationWithDefaultValue(PredefinedType(Token(SyntaxKind.BoolKeyword)), "__invokeSucceeded"));
        
            notify = notify.Insert(0, 
                ExpressionStatement(
                    AssignmentExpression(
                        SyntaxKind.SimpleAssignmentExpression, 
                        IdentifierName("__invokeSucceeded"), 
                        LiteralExpression(SyntaxKind.TrueLiteralExpression))));
        
            cleanupCallee = SingletonList<StatementSyntax>(
                        IfStatement(IdentifierName("__invokeSucceeded"), 
                        Block(guaranteedUnmarshal.AddRange(cleanupCallee))));
        }
        
        // wire up steps
        var finallyStatements = cleanupCallee.AddRange(cleanupCaller);

        StatementSyntax pinnedBlock = Block(pinnedMarshal.Add(ExpressionStatement(invoke)));

        for (var i = pin.Count - 1; i >= 0; i--)
        {
            pinnedBlock = pin[i].WithStatement(pinnedBlock);
        }

        var guarded = marshal
            .Add(pinnedBlock)
            .AddRange(notify)
            .AddRange(unmarshalCapture)
            .AddRange(unmarshal);
        
        statements = statements.AddRange(setup);

        if (finallyStatements.Any())
        {
            statements = statements.Add(TryStatement()
                .WithBlock(Block(guarded))
                .WithFinally(
                    FinallyClause(
                        Block(finallyStatements)))
            );
        }
        else
        {
            statements = statements.AddRange(guarded);
        }

        if (!ctx.Symbol.ReturnsVoid)
        {
            ExpressionSyntax returnExpression = IdentifierName("__retVal");

            if (ctx.ReturnsByRef)
            {
                returnExpression = RefExpression(
                    PrefixUnaryExpression(
                        SyntaxKind.PointerIndirectionExpression,
                        returnExpression));
            }

            statements = statements.Add(ReturnStatement(returnExpression));
        }

        return Block(statements);

    }
    
    private static ArgumentSyntax GetArgumentForParameter(ParameterStubGenerationContext ctx)
    {
        return ctx.MarshallerShape != null 
            ? ctx.MarshallerShape.GetArgument(ctx) 
            : WithParameterRefToken(Argument(IdentifierName(ctx.Symbol.Name)), ctx.Symbol);
    }

    private static ArgumentSyntax GetArgumentForParameter(IParameterSymbol symbol)
    {
        return WithParameterRefToken(Argument(IdentifierName(symbol.Name)), symbol);
    }

    /// <summary>
    /// Generate a step in the marshalling process with generated code for each parameter of the current method
    /// </summary>
    private static SyntaxList<TNode> Step<TNode>(
        MethodStubGenerationContext ctx,
        string? comment, 
        Func<IParameterSymbol, IMarshallerShape, SyntaxList<TNode>> marshaller,
        SyntaxList<TNode> additional = default) where TNode : SyntaxNode
    {
        var result = List(ctx.Parameters.Where(x => x.MarshallerShape != null)
            .SelectMany(x => marshaller(x.Symbol, x.MarshallerShape!)));

        result = result.AddRange(additional);

        if (comment != null && result.Count > 0)
        {
            result = result.Replace(result[0],
                result[0]
                    .WithLeadingTrivia(Comment(comment)));
        }

        return result;
    }
    
    /// <summary>
    /// Generate a step in the marshalling process with generated code for each parameter of the current method
    /// </summary>
    private static SyntaxList<TNode> Step<TNode>(
        MethodStubGenerationContext ctx,
        string? comment, 
        Func<IParameterSymbol, IMarshallerShape, TNode?> marshaller) where TNode : SyntaxNode
    {
        var result = List(ctx.Parameters.Where(x => x.MarshallerShape != null)
                .Select(x => marshaller(x.Symbol, x.MarshallerShape!))
                .Where(x => x != null)
                .Select(x => x!)
            );

        if (comment != null && result.Count > 0)
        {
            result = result.Replace(result[0],
                result[0]
                    .WithLeadingTrivia(Comment(comment)));
        }

        return result;
    }

    /// <summary>
    /// Returns a local function declaration for the extern function.
    /// </summary>
    private static LocalFunctionStatementSyntax GenerateExternFunction(MethodStubGenerationContext ctx, TypeSyntax externReturnType)
    {
        var handleParam = Parameter(Identifier("handle_")).WithType(ParseTypeName("nint"));

        return HelperSyntaxFactory.GenerateExternFunction(
            library: ctx.Library, 
            externName: ToExternName(ctx),
            externReturnType: externReturnType, 
            parameters: ctx.Parameters.Select(x => ToForwardInfo(x.Symbol, x.MarshallerShape)), 
            parametersPrefix: handleParam);
    }

    /// <summary>
    /// Returns the external native name of a function.
    /// </summary>
    private static string ToExternName(MethodStubGenerationContext ctx)
    {
        var overload = ctx.Symbol.GetAttribute(Constants.OverloadAttributeFQN)?.ConstructorArguments[0].Value as string;

        return ctx.Symbol.GetAttribute(Constants.FunctionAttributeFQN)?.ConstructorArguments[0].Value is string functionName 
            ? $"{ctx.NativeTypeName}_{functionName}" 
            : $"{ctx.NativeTypeName}_{StringUtil.FirstCharToLower(ctx.Symbol.Name)}{overload}";
    }
    
    /// <summary>
    /// Returns the struct generation context for a code gen context.
    /// </summary>
    private static StructStubGenerationContext? GetStructDeclaration(GeneratorAttributeSyntaxContext ctx, CancellationToken cancellationToken)
    {
        var targetNode = (StructDeclarationSyntax)ctx.TargetNode;
        if (ctx.TargetSymbol is not INamedTypeSymbol symbol)
            return null;

        var attribute = ctx.Attributes.Single();

        var library = attribute.NamedArguments.FirstOrDefault(x => x.Key == "Library")
            .Value.Value as string ?? "SampSharp";

        var nativeTypeName = attribute.NamedArguments.FirstOrDefault(x => x.Key == "NativeTypeName")
            .Value.Value as string ?? symbol.Name;

        var wellKnownMarshallerTypes = MarshallingCodeGenerator.GetWellKnownMarshallerTypes(ctx.SemanticModel.Compilation);

        var implementingTypes = attribute.ConstructorArguments[0]
            .Values.Select(x => (ITypeSymbol)x.Value!)
            .ToArray();

        var isComponent = implementingTypes.Any(x => x.ToDisplayString() == Constants.ComponentFQN);
        var isExtension = implementingTypes.Any(x => x.ToDisplayString() == Constants.ExtensionFQN);

        // filter methods: partial, non-static, non-generic
        var methods = targetNode.Members.OfType<MethodDeclarationSyntax>()
            .Where(x => x.IsPartial() && !x.HasModifier(SyntaxKind.StaticKeyword) && x.TypeParameterList == null)
            .Select(methodDeclaration => ctx.SemanticModel.GetDeclaredSymbol(methodDeclaration, cancellationToken) is not { } methodSymbol
                ? (null, null)
                : (methodDeclaration, methodSymbol))
            .Where(x => x.methodSymbol != null)
            .Select(method =>
            {
                var parameters = method.methodSymbol!.Parameters.Select(parameter =>
                        new ParameterStubGenerationContext(parameter, MarshallerShapeFactory.GetMarshallerShape(parameter, wellKnownMarshallerTypes)))
                    .ToArray();

                var returnMarshallerShape = MarshallerShapeFactory.GetMarshallerShape(method.methodSymbol, wellKnownMarshallerTypes);
                var requiresMarshalling = returnMarshallerShape != null || parameters.Any(x => x.MarshallerShape != null);

                if (returnMarshallerShape != null && (method.methodSymbol.ReturnsByRef || method.methodSymbol.ReturnsByRefReadonly))
                {
                    // marshalling return-by-ref not supported.
                    // TODO: diagnostic
                    return null;
                }
                
                return new MethodStubGenerationContext(method.methodDeclaration!, method.methodSymbol, parameters, returnMarshallerShape, requiresMarshalling, library, nativeTypeName);
            })
            .Where(x => x != null)
            .ToArray();

        return new StructStubGenerationContext(symbol, targetNode, methods!, implementingTypes, isExtension, isComponent);
    }
}