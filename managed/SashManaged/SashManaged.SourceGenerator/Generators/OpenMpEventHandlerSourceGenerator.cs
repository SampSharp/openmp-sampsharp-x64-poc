using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using SashManaged.SourceGenerator.Helpers;
using SashManaged.SourceGenerator.Marshalling;
using SashManaged.SourceGenerator.Models;
using SashManaged.SourceGenerator.SyntaxFactories;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using static SashManaged.SourceGenerator.SyntaxFactories.HelperSyntaxFactory;
using static SashManaged.SourceGenerator.SyntaxFactories.TypeSyntaxFactory;

namespace SashManaged.SourceGenerator.Generators;

/// <summary>
/// This source generator generates event handler interfaces for open.mp events. The generated interface contains a
/// default implementation for IncreaseReference/DecreaseReference methods, which are used to creating an unmanaged
/// event handler for the managed event handler. The implementation invokes the native function
/// `{EventHandlerName}Impl_create`/_delete to create the unmanaged event handler. The create call will include native
/// handles of delegate functions for every event method in the interface.
/// </summary>
[Generator]
public class OpenMpEventHandlerSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var attributedInterfaces = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                Constants.EventHandlerAttributeFQN, 
                static (s, _) => s is InterfaceDeclarationSyntax str && str.IsPartial(), 
                static(ctx, ct) => GetInterfaceDeclaration(ctx, ct))
            .Where(x => x is not null);

        
        context.RegisterSourceOutput(attributedInterfaces, (ctx, info) =>
        {
            var interfaceDeclaration = InterfaceDeclaration(info!.Syntax.Identifier)
                .WithModifiers(info.Syntax.Modifiers)
                .WithMembers(GenerateInterfaceMembers(info))
                .WithBaseList(
                    BaseList(SingletonSeparatedList<BaseTypeSyntax>(
                        SimpleBaseType(
                            GenericType(
                                Constants.EventHandlerFQN, 
                                ParseTypeName(info.Syntax.Identifier.ToString()))))))
                .WithAttributeLists(List([
                    AttributeFactory.GeneratedCode()
                ]));

            var namespaceDeclaration = NamespaceDeclaration(
                    ParseName(
                        info.Symbol.ContainingNamespace.ToDisplayString()))
                .AddMembers(interfaceDeclaration);

            var unit = CompilationUnit()
                .AddMembers(namespaceDeclaration)
                .WithLeadingTrivia(
                    TriviaFactory.AutoGeneratedComment());

            var sourceText = unit.NormalizeWhitespace()
                .GetText(Encoding.UTF8);

            ctx.AddSource($"{info.Symbol.Name}.g.cs", sourceText);
        });
    }

    private static SyntaxList<MemberDeclarationSyntax> GenerateInterfaceMembers(EventInterfaceStubGenerationContext ctx)
    {
        return List([
            GenerateManagerPropertyMember(ctx),
            GenerateManagerClass(ctx)
        ]);
    }
    
    private static MemberDeclarationSyntax GenerateManagerPropertyMember(EventInterfaceStubGenerationContext ctx)
    { 
        return PropertyDeclaration(
                AliasQualifiedName(
                    IdentifierName(
                        Token(SyntaxKind.GlobalKeyword)),
                    GenericName(
                            Identifier(Constants.INativeEventHandlerManagerFQN))
                        .WithTypeArgumentList(
                            TypeArgumentList(
                                SingletonSeparatedList<TypeSyntax>(
                                    IdentifierName(ctx.Symbol.Name))))),
                Identifier("Manager"))
            .WithModifiers(
                TokenList(
                    Token(SyntaxKind.StaticKeyword)))
            .WithExplicitInterfaceSpecifier(
                ExplicitInterfaceSpecifier(
                    AliasQualifiedName(
                        IdentifierName(
                            Token(SyntaxKind.GlobalKeyword)),
                        GenericName(
                                Identifier(Constants.EventHandlerFQN))
                            .WithTypeArgumentList(
                                TypeArgumentList(
                                    SingletonSeparatedList<TypeSyntax>(
                                        IdentifierName(ctx.Symbol.Name)))))))
            .WithExpressionBody(
                ArrowExpressionClause(
                    MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        IdentifierName("NativeEventHandlerManager"),
                        IdentifierName("Instance"))))
            .WithSemicolonToken(
                Token(SyntaxKind.SemicolonToken));
    }

    private static MemberDeclarationSyntax GenerateManagerClass(EventInterfaceStubGenerationContext ctx)
    {
        return ClassDeclaration(Identifier("NativeEventHandlerManager"))
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
            .WithBaseList(BaseList(
                SingletonSeparatedList<BaseTypeSyntax>(
                    SimpleBaseType(
                        GenericType(
                            Constants.NativeEventHandlerManagerFQN, 
                            ParseTypeName(ctx.Symbol.Name))))))
            .WithMembers(GenerateManagerMembers(ctx));
    }

    private static SyntaxList<MemberDeclarationSyntax> GenerateManagerMembers(EventInterfaceStubGenerationContext ctx)
    {
        return SingletonList(GenerateInstancePropertyMember())
            .AddRange(GenerateDelegateMembers(ctx))
            .AddRange([
                GenerateCreateMember(ctx),
                GenerateFreeMember(ctx)
            ]);
    }

    private static MemberDeclarationSyntax GenerateInstancePropertyMember()
    {
        return PropertyDeclaration(
                IdentifierName("NativeEventHandlerManager"),
                Identifier("Instance"))
            .WithModifiers(
                TokenList(
                    Token(SyntaxKind.PublicKeyword),
                    Token(SyntaxKind.StaticKeyword)))
            .WithAccessorList(
                AccessorList(
                    SingletonList(
                        AccessorDeclaration(
                                SyntaxKind.GetAccessorDeclaration)
                            .WithSemicolonToken(
                                Token(SyntaxKind.SemicolonToken)))))
            .WithInitializer(
                EqualsValueClause(
                    ImplicitObjectCreationExpression()))
            .WithSemicolonToken(
                Token(SyntaxKind.SemicolonToken));
    }

    private static MemberDeclarationSyntax GenerateCreateMember(EventInterfaceStubGenerationContext ctx)
    {
        // TODO: marshalling

        var delegateVars = ctx.Methods.Select(method =>
            VariableDeclarator(
                    Identifier($"__{method.Symbol.Name}_delegate"))
                .WithInitializer(
                    EqualsValueClause(
                        CastExpression(
                            IdentifierName($"{method.Symbol.Name}_"),
                            MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                IdentifierName("handler"),
                                IdentifierName(method.Symbol.Name))))));

        
        var functionPointerVars = ctx.Methods.Select(method => 
            VariableDeclarator(
                    Identifier($"__{method.Symbol.Name}_ptr"))
                .WithInitializer(
                    EqualsValueClause(
                        InvocationExpression(
                                MemberAccessExpression(
                                    SyntaxKind.SimpleMemberAccessExpression,
                                    TypeNameGlobal(Constants.MarshalFQN),
                                    IdentifierName(nameof(Marshal.GetFunctionPointerForDelegate))))
                            .WithArgumentList(
                                ArgumentList(
                                    SingletonSeparatedList(
                                        Argument(
                                            IdentifierName($"__{method.Symbol.Name}_delegate"))))))));

        // protected override (nint, object) Create(HandlerType handler)
        return MethodDeclaration(
                TupleType(
                    SeparatedList([
                        TupleElement(IntPtrType),
                        TupleElement(ObjectType)
                    ])),
                Identifier("Create"))
            .WithModifiers(
                TokenList(
                    Token(SyntaxKind.ProtectedKeyword), 
                    Token(SyntaxKind.OverrideKeyword)))
            .WithParameterList(
                ParameterList(
                    SingletonSeparatedList(
                        Parameter(
                                Identifier("handler"))
                            .WithType(ParseTypeName(ctx.Symbol.Name)))))
            .WithBody(
                Block(List<StatementSyntax>([
                    // Delegate __x_delegate = (Method_)handler.Method, ...;
                    LocalDeclarationStatement(
                        VariableDeclaration(
                                TypeNameGlobal(Constants.DelegateFQN))
                            .WithVariables(
                                SeparatedList(delegateVars))),
                    
                    // nint __x_ptr = Marshal.GetFunctionPointerForDelegate(__x_delegate), ...;
                    LocalDeclarationStatement(
                        VariableDeclaration(
                                IntPtrType)
                            .WithVariables(
                                SeparatedList(functionPointerVars))),

                    // object[] data == [ __x_delegate, ... ] ;
                    LocalDeclarationStatement(
                        VariableDeclaration(
                                ArrayType(
                                        PredefinedType(
                                            Token(SyntaxKind.ObjectKeyword)))
                                    .WithRankSpecifiers(
                                        SingletonList(
                                            ArrayRankSpecifier(
                                                SingletonSeparatedList<ExpressionSyntax>(
                                                    OmittedArraySizeExpression())))))
                            .WithVariables(
                                SingletonSeparatedList(
                                    VariableDeclarator(
                                            Identifier("data"))
                                        .WithInitializer(
                                            EqualsValueClause(
                                                CollectionExpression(
                                                    SeparatedList<CollectionElementSyntax>(
                                                        ctx.Methods.Select(method => 
                                                            ExpressionElement(
                                                                IdentifierName($"__{method.Symbol.Name}_delegate")))
                                                    ))))))),

                    // nint handle = __PInvoke(__x_ptr, ...);
                    LocalDeclarationStatement(
                        VariableDeclaration(
                                IntPtrType)
                            .WithVariables(
                                SingletonSeparatedList(
                                    VariableDeclarator(
                                            Identifier("handle"))
                                        .WithInitializer(
                                            EqualsValueClause(
                                                InvocationExpression(
                                                        IdentifierName("__PInvoke"))
                                                    .WithArgumentList(
                                                        ArgumentList(
                                                            SeparatedList(ctx.Methods.Select(method =>
                                                                Argument(
                                                                    IdentifierName($"__{method.Symbol.Name}_ptr"))))))))))),

                    // return (handle, data);
                    ReturnStatement(
                        TupleExpression(
                            SeparatedList([
                                Argument(
                                        IdentifierName("handle")),
                                    Argument(
                                        IdentifierName("data"))]))),

                    // static extern nint __PInvoke(...);
                    GenerateExternFunctionCreate(ctx)
                ])));
    }

    private static MemberDeclarationSyntax GenerateFreeMember(EventInterfaceStubGenerationContext ctx)
    {
        return MethodDeclaration(
                PredefinedType(
                    Token(SyntaxKind.VoidKeyword)),
                Identifier("Free"))
            .WithModifiers(
                TokenList(
                    Token(SyntaxKind.ProtectedKeyword), 
                    Token(SyntaxKind.OverrideKeyword)))
            .WithParameterList(
                ParameterList(
                    SingletonSeparatedList(
                        Parameter(
                                Identifier("handle"))
                            .WithType(IntPtrType))))
            .WithBody(
                Block(
                    ExpressionStatement(
                        InvocationExpression(
                                IdentifierName("__PInvoke"))
                            .WithArgumentList(
                                ArgumentList(
                                    SingletonSeparatedList(
                                        Argument(
                                            IdentifierName("handle")))))),
                    GenerateExternFunctionDelete(ctx)
                ));
    }

    private static IEnumerable<DelegateDeclarationSyntax> GenerateDelegateMembers(EventInterfaceStubGenerationContext ctx)
    {
        return ctx.Methods.Select(method =>
        {
            var parameters = ToParameterListSyntax([], method.Parameters.Select(x => ToForwardInfo(x.Symbol, x.MarshallerShape, false)));
            var returnType = method.ReturnMarshallerShape?.GetNativeType() ?? 
                             TypeNameGlobal(method.Symbol.ReturnType);

            return DelegateDeclaration(
                    returnType,
                    Identifier($"{method.Symbol.Name}_"))
                .WithModifiers(
                    TokenList(
                        Token(SyntaxKind.PrivateKeyword)))
                .WithParameterList(parameters);
        });
    }

    private static LocalFunctionStatementSyntax GenerateExternFunctionCreate(EventInterfaceStubGenerationContext ctx)
    {
        var parameters = ctx.Methods.Select(x => new ParamForwardInfo($"_{x.Symbol.Name}", IntPtrType, RefKind.None));

        return GenerateExternFunction(
            library: ctx.Library, 
            externName: $"{ctx.NativeTypeName}Impl_create",
            externReturnType: IntPtrType, 
            parameters: parameters);
    }
    
    private static LocalFunctionStatementSyntax GenerateExternFunctionDelete(EventInterfaceStubGenerationContext ctx)
    {
        return GenerateExternFunction(
            library: ctx.Library, 
            externName: $"{ctx.NativeTypeName}Impl_delete",
            externReturnType: PredefinedType(Token(SyntaxKind.VoidKeyword)), 
            parameters: [new ParamForwardInfo("ptr", IntPtrType, RefKind.None)]);
    }

    /// <summary>
    /// Returns a context for the generation of the interface declaration.
    /// </summary>
    private static EventInterfaceStubGenerationContext? GetInterfaceDeclaration(GeneratorAttributeSyntaxContext ctx, CancellationToken cancellationToken)
    {
        var targetNode = (InterfaceDeclarationSyntax)ctx.TargetNode;
        if (ctx.TargetSymbol is not INamedTypeSymbol symbol)
            return null;

        var attribute = ctx.Attributes.Single();

        var library = attribute.NamedArguments.FirstOrDefault(x => x.Key == "Library")
            .Value.Value as string ?? "SampSharp";

        var nativeTypeName = attribute.NamedArguments.FirstOrDefault(x => x.Key == "NativeTypeName")
            .Value.Value as string ?? (symbol.Name.StartsWith("I") ? symbol.Name.Substring(1) : symbol.Name);

        var wellKnownMarshallerTypes = MarshallingCodeGenerator.GetWellKnownMarshallerTypes(ctx.SemanticModel.Compilation);

        // filter methods: non-static
        var methods = targetNode.Members.OfType<MethodDeclarationSyntax>()
            .Where(x => !x.HasModifier(SyntaxKind.StaticKeyword))
            .Select(methodDeclaration => ctx.SemanticModel.GetDeclaredSymbol(methodDeclaration, cancellationToken) is not { } methodSymbol
                ? (null, null)
                : (methodDeclaration, methodSymbol))
            .Where(x => x.methodSymbol != null)
            .Select(method =>
            {
                var parameters = method.methodSymbol!.Parameters.Select(parameter =>
                        new ParameterStubGenerationContext(parameter, MarshallerShapeFactory.GetMarshallerShape(parameter, wellKnownMarshallerTypes)))
                    .ToArray();

                var returnMarshallerShape = MarshallerShapeFactory.GetMarshallerShape(method.methodSymbol, wellKnownMarshallerTypes);
                var requiresMarshalling = returnMarshallerShape != null || parameters.Any(x => x.MarshallerShape != null);

                if (returnMarshallerShape != null && (method.methodSymbol.ReturnsByRef || method.methodSymbol.ReturnsByRefReadonly))
                {
                    // marshalling return-by-ref not supported.
                    // TODO: diagnostic
                    return null;
                }

                return new EventMethodStubGenerationContext(method.methodDeclaration!, method.methodSymbol, parameters, returnMarshallerShape, requiresMarshalling);
            })
            .Where(x => x != null)
            .ToArray();

        return new EventInterfaceStubGenerationContext(symbol, targetNode, methods!, library, nativeTypeName);
    }
}