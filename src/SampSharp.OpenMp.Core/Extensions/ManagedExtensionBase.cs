using System.Runtime.InteropServices;
using SampSharp.OpenMp.Core.Api;

namespace SampSharp.OpenMp.Core;

public abstract class ManagedExtensionBase<T> : IAutoGeneratedManagedExtension where T : IManagedExtension
{
    // ReSharper disable once PrivateFieldCanBeConvertedToLocalVariable
    private readonly Action _free;
    private nint? _unmanagedCounterpart;
    private GCHandle? _gcHandle;

    private IExtensible? _appliedTo;

    protected ManagedExtensionBase()
    {
        _free = FreeExtension;
        var id = T.ExtensionId;
        var free = Marshal.GetFunctionPointerForDelegate(_free);
        var handle = GCHandle.Alloc(this, GCHandleType.Normal);

        _gcHandle = handle;
        _unmanagedCounterpart = ManagedExtensionInterop.CreateInternal(id, free, GCHandle.ToIntPtr(handle));
    }

    nint IAutoGeneratedManagedExtension.GetUnmanaged()
    {
        ObjectDisposedException.ThrowIf(!_unmanagedCounterpart.HasValue, GetType());
        
        return _unmanagedCounterpart.Value;
    }

    ~ManagedExtensionBase()
    {
        Free();
    }

    private void Free()
    {
        FreeUnmanagedCounterpart();
        FreeHandle();
    }

    private void FreeUnmanagedCounterpart()
    {
        if (_unmanagedCounterpart.HasValue)
        {
            ManagedExtensionInterop.Delete(_unmanagedCounterpart.Value);
            _unmanagedCounterpart = null;
            _appliedTo = null;
        }
    }

    private void FreeHandle()
    {
        if (_gcHandle.HasValue)
        {
            _gcHandle.Value.Free();
            _gcHandle = null;
        }
    }
    
    private void Detach()
    {
        if (_appliedTo.HasValue && _unmanagedCounterpart.HasValue)
        {
            _appliedTo.Value.RemoveExtension(new IExtension(_unmanagedCounterpart.Value));
            _appliedTo = null;
        }
    }

    internal void ApplyTo(IExtensible extensible)
    {
        if (_appliedTo.HasValue)
        {
            throw new InvalidOperationException("Can only apply to one extensible");
        }

        _appliedTo = extensible;
    }

    private void FreeExtension()
    {
        try
        {
            _appliedTo = null;
            Cleanup();
        }
        catch(Exception e)
        {
            // TODO: error handling
            Console.WriteLine(e);
        }
        finally
        {
            FreeHandle();
        }
    }

    protected virtual void Cleanup()
    {
    }

    public void Dispose()
    {
        Detach();

        Free();
        GC.SuppressFinalize(this);
    }
}