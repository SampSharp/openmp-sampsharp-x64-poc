namespace SampSharp.OpenMp.Core.Api;

/// <summary>
/// Represents a base class for event handler marshallers. This type is automatically generated by code generated for
/// event handlers decorated with the <see cref="OpenMpEventHandlerAttribute" />.
/// </summary>
/// <typeparam name="TEventHandler">The type of the event handler.</typeparam>
public abstract class EventHandlerMarshaller<TEventHandler> : IEventHandlerMarshaller<TEventHandler> where TEventHandler : class
{
    private readonly Dictionary<TEventHandler, HandlerData> _handlers = [];

    /// <inheritdoc />
    public EventHandlerReference<TEventHandler> Marshal(TEventHandler handler)
    {
        return new EventHandlerReference<TEventHandler>(this, handler);
    }

    internal nint IncreaseReferenceCount(TEventHandler handler)
    {
        if (_handlers.TryGetValue(handler, out var reference))
        {
            _handlers[handler] = reference with
            {
                RefCount = reference.RefCount + 1
            };

            return reference.Handle;
        }

        var (newHandle, data) = Create(handler);

        _handlers[handler] = new HandlerData(newHandle, 1, data);

        return newHandle;
    }

    internal void DecreaseReferenceCount(TEventHandler handler)
    {
        if (!_handlers.TryGetValue(handler, out var reference))
        {
            return;
        }

        if (reference.RefCount == 1)
        {
            _handlers.Remove(handler);
            Free(reference.Handle);
        }

        _handlers[handler] = reference with
        {
            RefCount = reference.RefCount - 1
        };
    }
    
    internal nint? GetReference(TEventHandler handler)
    {
        return _handlers.TryGetValue(handler, out var reference) 
            ? reference.Handle 
            : null;
    }

    /// <summary>
    /// Creates the unmanaged counterpart of the specified event <paramref name="handler" />.
    /// </summary>
    /// <param name="handler">The event handler for which to create the unmanaged counterpart.</param>
    /// <returns>An unmanaged handle and an object of luggage which will be kept so GC won't clean it up.</returns>
    protected abstract (nint, object) Create(TEventHandler handler);

    /// <summary>
    /// Frees the resources associated with the specified unmanaged <paramref name="handle" />.
    /// </summary>
    /// <param name="handle">The unmanaged handle to free.</param>
    protected abstract void Free(nint handle);

    private readonly record struct HandlerData(nint Handle, int RefCount, object Luggage);

}