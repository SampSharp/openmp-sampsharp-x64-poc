using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace SampSharp.SourceGenerator.SyntaxFactories;

/// <summary>
/// Creates trivia syntax.
/// </summary>
public static class TriviaFactory
{
    public static SyntaxTrivia AutoGeneratedComment()
    {
        return Comment("// <auto-generated />");
    }

    public static SyntaxTriviaList InheritDoc()
    {
        return TriviaList(
            Trivia(
                DocumentationCommentTrivia(
                    SyntaxKind.SingleLineDocumentationCommentTrivia,
                    List<XmlNodeSyntax>([
                        XmlText("/// "),
                        XmlEmptyElement("inheritdoc"),
                        XmlText()
                            .WithTextTokens(
                            TokenList(
                                XmlTextNewLine("\n", false)))

                    ]))));
    }

    private static TypeSyntax StripGenericParameters(TypeSyntax type)
    {
        if (type is QualifiedNameSyntax qual)
        {
            return qual.WithRight((SimpleNameSyntax)StripGenericParameters(qual.Right));
        }

        if (type is GenericNameSyntax { TypeArgumentList.Arguments.Count: > 0 } gen)
        {
            if (gen.TypeArgumentList.Arguments.Count == 1)
            {
                return gen.WithTypeArgumentList(
                    TypeArgumentList(
                        SingletonSeparatedList(
                            ParseTypeName("T"))));
            }

            return gen.WithTypeArgumentList(
                TypeArgumentList(
                    SeparatedList(
                        Enumerable.Range(1, gen.TypeArgumentList.Arguments.Count)
                            .Select(i => ParseTypeName($"T{i}")))));
        }

        return type;
    }

    public static XmlNodeSyntax SeeElement(TypeSyntax crefType)
    {
        return XmlEmptyElement("see")
            .WithAttributes(
                SingletonList<XmlAttributeSyntax>(
                    XmlCrefAttribute(
                        NameMemberCref(
                            StripGenericParameters(crefType)))));
    } 

    public static XmlNodeSyntax CElement(string c)
    {
        return XmlElement(
            XmlElementStartTag(
                XmlName("c")),
            SingletonList<XmlNodeSyntax>(
                XmlText(c)),
            XmlElementEndTag(
                XmlName("c"))
        );
    } 

    public static SyntaxTriviaList DocsStructConstructor(TypeSyntax structType, params ParameterDoc[] parameters)
    {
        var summary = List([
            XmlText("Initializes a new instance of the "),
            SeeElement(structType),
            XmlText(" struct."),
        ]);

        return Docs(summary, parameters);
    }

    public static SyntaxTriviaList DocsOpEqual()
    {
        return Docs(
            List<XmlNodeSyntax>([
                XmlText("Determines whether the specified values are equal."),
            ]), [
                new ParameterDoc("lhs", "The value on the left side of the operator."),
                new ParameterDoc("rhs", "The value on the right side of the operator.")
            ], List([
                CElement("true"),
                XmlText(" if the values are equal; otherwise, "),
                CElement("false"),
                XmlText("."),
            ]));
    }

    public static SyntaxTriviaList DocsOpNotEqual()
    {
        return Docs(
            List<XmlNodeSyntax>([
                XmlText("Determines whether the specified values are not equal."),
            ]), [
                new ParameterDoc("lhs", "The value on the left side of the operator."),
                new ParameterDoc("rhs", "The value on the right side of the operator.")
            ], List([
                CElement("true"),
                XmlText(" if the values are not equal; otherwise, "),
                CElement("false"),
                XmlText("."),
            ]));
    }

    public static SyntaxTriviaList DocsOpCast(TypeSyntax from, TypeSyntax to)
    {
        return Docs(
            List([
                XmlText("Casts the "),
                SeeElement(from),
                XmlText(" to a "),
                SeeElement(to),
                XmlText("."),
            ]), [
                new ParameterDoc("value", List([
                    XmlText("The "),
                    SeeElement(from),
                    XmlText(" to cast.")
                    ])),
            ], List([
                XmlText("The converted "),
                SeeElement(to),
                XmlText(".")]));
    }
    public static SyntaxTriviaList Docs(string summary, ParameterDoc[] parameters, string? returns = null)
    {
        var r = returns == null 
            ? (SyntaxList<XmlNodeSyntax>?)null
            : SingletonList<XmlNodeSyntax>(XmlText(summary));

        return Docs(SingletonList<XmlNodeSyntax>(XmlText(summary)), parameters, r);
    }

    public static SyntaxTriviaList Docs(SyntaxList<XmlNodeSyntax> summary, ParameterDoc[] parameters, SyntaxList<XmlNodeSyntax>? returns = null)
    {
        var nodes = new List<XmlNodeSyntax>
        {
            XmlText("/// "),
            XmlElement(
                XmlElementStartTag(
                    XmlName("summary")),
                summary,
                XmlElementEndTag(
                    XmlName("summary"))
            ),
            XmlText()
                .WithTextTokens(
                TokenList(
                    XmlTextNewLine("\n", false)
                )
            )
        };

        foreach (var parameter in parameters)
        {
            nodes.AddRange([
                XmlText("/// "),
                XmlElement(
                    XmlElementStartTag(
                        XmlName("param"))
                        .AddAttributes(
                            XmlTextAttribute(
                                "name", 
                                parameter.Name)),
                    parameter.Content,
                    XmlElementEndTag(XmlName("param"))
                ),
                XmlText().WithTextTokens(
                    TokenList(
                        XmlTextNewLine("\n", false)
                    )
                )
            ]);
        }

        if (returns.HasValue)
        {
            nodes.AddRange([
                XmlText("/// "),
                XmlElement(
                    XmlElementStartTag(XmlName("returns")),
                    returns.Value,
                    XmlElementEndTag(XmlName("returns"))
                ),
                XmlText().WithTextTokens(
                    TokenList(
                        XmlTextNewLine("\n", false)
                    )
                )
            ]);
        }

        return TriviaList(
            Trivia(
                DocumentationCommentTrivia(
                    SyntaxKind.SingleLineDocumentationCommentTrivia,
                    List(nodes)
                )
            )
        );
    }

    public readonly record struct ParameterDoc(string Name, SyntaxList<XmlNodeSyntax> Content)
    {
        public ParameterDoc(string name, string text) : this(name, SingletonList<XmlNodeSyntax>(XmlText(text)))
        {
        }
    }

    public static SyntaxTrivia NullableEnable()
    {
        return Trivia(
            NullableDirectiveTrivia(
                Token(SyntaxKind.EnableKeyword),
                true));
    }
    public static SyntaxTrivia NullableDisable()
    {
        return Trivia(
            NullableDirectiveTrivia(
                Token(SyntaxKind.DisableKeyword),
                false));
    }
}