using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using SampSharp.SourceGenerator.Generators.Marshalling;
using SampSharp.SourceGenerator.Generics;
using SampSharp.SourceGenerator.Helpers;
using SampSharp.SourceGenerator.Marshalling;
using SampSharp.SourceGenerator.Models;
using SampSharp.SourceGenerator.SyntaxFactories;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using static SampSharp.SourceGenerator.SyntaxFactories.HelperSyntaxFactory;
using static SampSharp.SourceGenerator.SyntaxFactories.TypeSyntaxFactory;

namespace SampSharp.SourceGenerator.Generators;

/// <summary>
/// This source generator generates event handler interfaces for open.mp events. The generated interface contains a
/// default implementation for IncreaseReference/DecreaseReference methods, which are used to creating an unmanaged
/// event handler for the managed event handler. The implementation invokes the native function
/// `{EventHandlerName}Impl_create`/_delete to create the unmanaged event handler. The create call will include native
/// handles of delegate functions for every event method in the interface.
/// </summary>
[Generator]
public class OpenMpEventHandlerSourceGenerator : IIncrementalGenerator
{
    private const string ClassEventHandlerMarshaller = "EventHandlerMarshaller";
    private const string LocalHandle = "handle";
    private const string ParamHandle = "handle";
    private const string MethodPInvoke = "__PInvoke";
    private static readonly SyntaxToken _idToken = Identifier("Marshaller");
    private static readonly SyntaxToken _idInstance = Identifier("Instance");

    private static readonly ApiEventDelegateMarshallingGenerator _marshallingGenerator = new();

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var attributedInterfaces = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                Constants.EventHandlerAttributeFQN, 
                static (s, _) => s is InterfaceDeclarationSyntax str && str.IsPartial(), 
                static(ctx, ct) => GetInterfaceDeclaration(ctx, ct))
            .Where(x => x is not null);

        
        context.RegisterSourceOutput(attributedInterfaces, (ctx, info) =>
        {
            var interfaceDeclaration = InterfaceDeclaration(info!.Syntax.Identifier)
                .WithModifiers(info.Syntax.Modifiers)
                .WithMembers(GenerateInterfaceMembers(info))
                .WithBaseList(
                    BaseList(SingletonSeparatedList<BaseTypeSyntax>(
                        SimpleBaseType(
                            GenericType(
                                Constants.EventHandlerFQN, 
                                ParseTypeName(info.Syntax.Identifier.ToString()))))))
                .WithAttributeLists(List([
                    AttributeFactory.GeneratedCode()
                ]));

            if (info.Syntax.TypeParameterList != null)
            {
                interfaceDeclaration = interfaceDeclaration.WithTypeParameterList(info.Syntax.TypeParameterList);
            }

            var namespaceDeclaration = NamespaceDeclaration(
                    ParseName(
                        info.Symbol.ContainingNamespace.ToDisplayString()))
                .AddMembers(interfaceDeclaration);

            var unit = CompilationUnit()
                .AddMembers(namespaceDeclaration)
                .WithLeadingTrivia(
                    TriviaFactory.AutoGeneratedComment());

            var sourceText = unit.NormalizeWhitespace()
                .GetText(Encoding.UTF8);

            ctx.AddSource($"{info.Symbol.Name}.g.cs", sourceText);
        });
    }

    private static SyntaxList<MemberDeclarationSyntax> GenerateInterfaceMembers(EventInterfaceStubGenerationContext ctx)
    {
        return List<MemberDeclarationSyntax>([
            GenerateManagerPropertyMember(ctx),
            GenerateManagerClass(ctx)
        ]);
    }

    private static PropertyDeclarationSyntax GenerateManagerPropertyMember(EventInterfaceStubGenerationContext ctx)
    { 
        return PropertyDeclaration(
                AliasQualifiedName(
                    IdentifierName(
                        Token(SyntaxKind.GlobalKeyword)),
                    GenericName(
                            Identifier(Constants.IEventHandlerMarshallerFQN))
                        .WithTypeArgumentList(
                            TypeArgumentList(
                                SingletonSeparatedList(ctx.Type)))),
                _idToken)
            .WithModifiers(
                TokenList(
                    Token(SyntaxKind.StaticKeyword)))
            .WithExplicitInterfaceSpecifier(
                ExplicitInterfaceSpecifier(
                    AliasQualifiedName(
                        IdentifierName(
                            Token(SyntaxKind.GlobalKeyword)),
                        GenericName(
                                Identifier(Constants.EventHandlerFQN))
                            .WithTypeArgumentList(
                                TypeArgumentList(
                                    SingletonSeparatedList(ctx.Type))))))
            .WithExpressionBody(
                ArrowExpressionClause(
                    MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        IdentifierName(ClassEventHandlerMarshaller),
                        IdentifierName("Instance"))))
            .WithSemicolonToken(
                Token(SyntaxKind.SemicolonToken));
    }

    private static ClassDeclarationSyntax GenerateManagerClass(EventInterfaceStubGenerationContext ctx)
    {
        return ClassDeclaration(Identifier(ClassEventHandlerMarshaller))
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
            .WithBaseList(BaseList(
                SingletonSeparatedList<BaseTypeSyntax>(
                    SimpleBaseType(
                        GenericType(
                            Constants.EventHandlerMarshallerFQN, 
                            ParseTypeName(ctx.Symbol.Name))))))
            .WithLeadingTrivia(TriviaFactory.Docs([
                XmlText("Manages the marshalling of native event handlers for "),
                TriviaFactory.SeeElement(
                    ParseTypeName(ctx.Symbol.Name)),
                XmlText(".")
                ], []))
            .WithMembers(GenerateManagerMembers(ctx));
    }

    private static SyntaxList<MemberDeclarationSyntax> GenerateManagerMembers(EventInterfaceStubGenerationContext ctx)
    {
        return SingletonList<MemberDeclarationSyntax>(GenerateInstancePropertyMember())
            .AddRange(GenerateDelegateMembers(ctx))
            .AddRange([
                GenerateCreateMember(ctx),
                GenerateFreeMember(ctx)
            ]);
    }

    private static PropertyDeclarationSyntax GenerateInstancePropertyMember()
    {
        return PropertyDeclaration(
                IdentifierName(ClassEventHandlerMarshaller),
                _idInstance)
            .WithModifiers(
                TokenList(
                    Token(SyntaxKind.PublicKeyword),
                    Token(SyntaxKind.StaticKeyword)))
            .WithAccessorList(
                AccessorList(
                    SingletonList(
                        AccessorDeclaration(
                                SyntaxKind.GetAccessorDeclaration)
                            .WithSemicolonToken(
                                Token(SyntaxKind.SemicolonToken)))))
            .WithInitializer(
                EqualsValueClause(
                    ImplicitObjectCreationExpression()))
            .WithLeadingTrivia(
                TriviaFactory.Docs([
                    XmlText("Gets the singleton instance of the "),
                    TriviaFactory.SeeElement(
                        IdentifierName(ClassEventHandlerMarshaller)),
                    XmlText("."),
                ], []))
            .WithSemicolonToken(
                Token(SyntaxKind.SemicolonToken));
    }

    private static MethodDeclarationSyntax GenerateCreateMember(EventInterfaceStubGenerationContext ctx)
    {
        var delegateVars = ctx.Methods.Select(method =>
            VariableDeclarator(
                    Identifier($"__{method.Symbol.Name}_delegate"))
                .WithInitializer(
                    EqualsValueClause(
                        GenerateDelegateExpression(method))));

        
        var functionPointerVars = ctx.Methods.Select(method => 
            VariableDeclarator(
                    Identifier($"__{method.Symbol.Name}_ptr"))
                .WithInitializer(
                    EqualsValueClause(
                        InvocationExpression(
                                MemberAccessExpression(
                                    SyntaxKind.SimpleMemberAccessExpression,
                                    TypeNameGlobal(Constants.MarshalFQN),
                                    IdentifierName(nameof(Marshal.GetFunctionPointerForDelegate))))
                            .WithArgumentList(
                                ArgumentList(
                                    SingletonSeparatedList(
                                        Argument(
                                            IdentifierName($"__{method.Symbol.Name}_delegate"))))))));

        // protected override (nint, object) Create(HandlerType handler)
        return MethodDeclaration(
                TupleType(
                    SeparatedList([
                        TupleElement(IntPtrType),
                        TupleElement(ObjectType)
                    ])),
                Identifier("Create"))
            .WithModifiers(
                TokenList(
                    Token(SyntaxKind.ProtectedKeyword), 
                    Token(SyntaxKind.OverrideKeyword)))
            .WithParameterList(
                ParameterList(
                    SingletonSeparatedList(
                        Parameter(
                                Identifier("handler"))
                            .WithType(ParseTypeName(ctx.Symbol.Name)))))
            .WithLeadingTrivia(
                TriviaFactory.InheritDoc())
            .WithBody(
                Block(List<StatementSyntax>([
                    // Delegate __x_delegate = (Method_)handler.Method, ...;
                    LocalDeclarationStatement(
                        VariableDeclaration(
                                TypeNameGlobal(Constants.DelegateFQN))
                            .WithVariables(
                                SeparatedList(delegateVars))),
                    
                    // nint __x_ptr = Marshal.GetFunctionPointerForDelegate(__x_delegate), ...;
                    LocalDeclarationStatement(
                        VariableDeclaration(
                                IntPtrType)
                            .WithVariables(
                                SeparatedList(functionPointerVars))),

                    // object[] data == [ __x_delegate, ... ] ;
                    LocalDeclarationStatement(
                        VariableDeclaration(
                                ArrayType(
                                        PredefinedType(
                                            Token(SyntaxKind.ObjectKeyword)))
                                    .WithRankSpecifiers(
                                        SingletonList(
                                            ArrayRankSpecifier(
                                                SingletonSeparatedList<ExpressionSyntax>(
                                                    OmittedArraySizeExpression())))))
                            .WithVariables(
                                SingletonSeparatedList(
                                    VariableDeclarator(
                                            Identifier("data"))
                                        .WithInitializer(
                                            EqualsValueClause(
                                                CollectionExpression(
                                                    SeparatedList<CollectionElementSyntax>(
                                                        ctx.Methods.Select(method => 
                                                            ExpressionElement(
                                                                IdentifierName($"__{method.Symbol.Name}_delegate")))
                                                    ))))))),

                    // nint handle = __PInvoke(__x_ptr, ...);
                    LocalDeclarationStatement(
                        VariableDeclaration(
                                IntPtrType)
                            .WithVariables(
                                SingletonSeparatedList(
                                    VariableDeclarator(
                                            Identifier(LocalHandle))
                                        .WithInitializer(
                                            EqualsValueClause(
                                                InvocationExpression(
                                                        IdentifierName(MethodPInvoke))
                                                    .WithArgumentList(
                                                        ArgumentList(
                                                            SeparatedList(ctx.Methods.Select(method =>
                                                                Argument(
                                                                    IdentifierName($"__{method.Symbol.Name}_ptr"))))))))))),

                    // return (handle, data);
                    ReturnStatement(
                        TupleExpression(
                            SeparatedList([
                                Argument(
                                        IdentifierName(LocalHandle)),
                                    Argument(
                                        IdentifierName("data"))]))),

                    // static extern nint __PInvoke(...);
                    GenerateExternFunctionCreate(ctx)
                ])));
    }

    private static ExpressionSyntax GenerateDelegateExpression(MarshallingStubGenerationContext method)
    {
        return _marshallingGenerator.GenerateDelegateExpression(method);
    }

    private static MethodDeclarationSyntax GenerateFreeMember(EventInterfaceStubGenerationContext ctx)
    {
        return MethodDeclaration(
                PredefinedType(
                    Token(SyntaxKind.VoidKeyword)),
                Identifier("Free"))
            .WithModifiers(
                TokenList(
                    Token(SyntaxKind.ProtectedKeyword), 
                    Token(SyntaxKind.OverrideKeyword)))
            .WithParameterList(
                ParameterList(
                    SingletonSeparatedList(
                        Parameter(
                                Identifier(ParamHandle))
                            .WithType(IntPtrType))))
            .WithLeadingTrivia(
                TriviaFactory.InheritDoc())
            .WithBody(
                Block(
                    ExpressionStatement(
                        InvocationExpression(
                                IdentifierName(MethodPInvoke))
                            .WithArgumentList(
                                ArgumentList(
                                    SingletonSeparatedList(
                                        Argument(
                                            IdentifierName(ParamHandle)))))),
                    GenerateExternFunctionDelete(ctx)
                ));
    }

    private static IEnumerable<DelegateDeclarationSyntax> GenerateDelegateMembers(EventInterfaceStubGenerationContext ctx)
    {
        return ctx.Methods.Select(method =>
        {
            var parameters = ToParameterListSyntax([], method.Parameters.Select(x => ToForwardInfo(x)));
            var returnType = method.ReturnValue.Generator.GetNativeType(method.ReturnValue);
            
            return DelegateDeclaration(
                    returnType,
                    Identifier($"{method.Symbol.Name}_"))
                .WithModifiers(
                    TokenList(
                        Token(SyntaxKind.PrivateKeyword)))
                .WithParameterList(parameters);
        });
    }

    private static LocalFunctionStatementSyntax GenerateExternFunctionCreate(EventInterfaceStubGenerationContext ctx)
    {
        var parameters = ctx.Methods.Select(x => new ParamForwardInfo($"_{x.Symbol.Name}", IntPtrType, RefKind.None));

        return GenerateExternFunction(
            library: ctx.Library, 
            externName: $"{ctx.NativeTypeName}Impl_create",
            externReturnType: IntPtrType, 
            parameters: parameters);
    }
    
    private static LocalFunctionStatementSyntax GenerateExternFunctionDelete(EventInterfaceStubGenerationContext ctx)
    {
        return GenerateExternFunction(
            library: ctx.Library, 
            externName: $"{ctx.NativeTypeName}Impl_delete",
            externReturnType: PredefinedType(Token(SyntaxKind.VoidKeyword)), 
            parameters: [new ParamForwardInfo("ptr", IntPtrType, RefKind.None)]);
    }

    /// <summary>
    /// Returns a context for the generation of the interface declaration.
    /// </summary>
    private static EventInterfaceStubGenerationContext? GetInterfaceDeclaration(GeneratorAttributeSyntaxContext ctx, CancellationToken cancellationToken)
    {
        var targetNode = (InterfaceDeclarationSyntax)ctx.TargetNode;
        
        if (ctx.TargetSymbol is not INamedTypeSymbol symbol)
        {
            return null;
        }

        var attribute = ctx.Attributes.Single();

        var library = attribute.NamedArguments.FirstOrDefault(x => x.Key == "Library")
            .Value.Value as string ?? "SampSharp";

        var nativeTypeName = attribute.NamedArguments.FirstOrDefault(x => x.Key == "NativeTypeName")
            .Value.Value as string ?? (symbol.Name.StartsWith("I") ? symbol.Name.Substring(1) : symbol.Name);

        var wellKnownMarshallerTypes = WellKnownMarshallerTypes.Create(ctx.SemanticModel.Compilation);
        var ctxFactory = new IdentifierStubContextFactory(wellKnownMarshallerTypes);


        // filter methods: non-static
        var methods = InterfaceResolver.GetInterfaces(ctx.SemanticModel, targetNode)
            .SelectMany(iface => iface.GetInstanceMethods())
            .Select(x =>
            {
                var model = ctx.SemanticModel;
                if (x.Interface.Syntax.SyntaxTree != model.SyntaxTree)
                {
                    model = model.Compilation.GetSemanticModel(x.Interface.Syntax.SyntaxTree);
                }
                
                return model.GetDeclaredSymbol(x.Method, cancellationToken) is { } methodSymbol ? (method: x, methodSymbol) : default;
            })
            .Where(x => x.methodSymbol != null)
            .Select(x =>
            {
                var parameters = x.methodSymbol!.Parameters.Select(parameter => ctxFactory.Create(parameter, x.method.Interface.Resolve(parameter.Type), MarshalDirection.UnmanagedToManaged))
                    .ToArray();

                var returnValueContext = ctxFactory.Create(x.methodSymbol, x.method.Interface.Resolve(x.methodSymbol.ReturnType), MarshalDirection.ManagedToUnmanaged);
                if (returnValueContext.Shape != MarshallerShape.None && (x.methodSymbol.ReturnsByRef || x.methodSymbol.ReturnsByRefReadonly))
                {
                    // marshalling return-by-ref not supported.
                    return null;
                }

                return new MarshallingStubGenerationContext(x.methodSymbol, parameters, returnValueContext);
            })
            .Where(x => x != null)
            .ToArray();

        return new EventInterfaceStubGenerationContext(symbol, targetNode, methods!, library, nativeTypeName);
    }
}