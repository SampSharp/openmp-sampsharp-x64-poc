using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using SampSharp.SourceGenerator.Generators.ApiStructs;
using SampSharp.SourceGenerator.Helpers;
using SampSharp.SourceGenerator.Marshalling;
using SampSharp.SourceGenerator.Models;
using SampSharp.SourceGenerator.SyntaxFactories;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using static SampSharp.SourceGenerator.SyntaxFactories.TypeSyntaxFactory;

namespace SampSharp.SourceGenerator.Generators;

/// <summary>
/// This source generator generates the marshalling interop methods for open.mp API structs. The generator generates the
/// following:
/// <list type="bullet">
///     <item>P/Invoke every partial method in the interface with marshalling of every parameter and return value</item>
///     <item>For every "implementing" interface specified in the CodeGen attribute generate the following:
///        <list type="bullet">
///             <item>Pass-through implementations of all methods in the implementing interface</item>
///         </list>
///     </item>
/// </list>
/// </summary>
[Generator]
public class OpenMpApiSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var attributedStructs = context.SyntaxProvider.ForAttributeWithMetadataName(
                Constants.ApiAttributeFQN,
                static (s, _) => s is StructDeclarationSyntax str && str.IsPartial(), 
                static (ctx, ct) => GetStructDeclaration(ctx, ct))
            .Where(x => x is not null);

        context.RegisterSourceOutput(attributedStructs, (ctx, info) =>
        {
            var unit = GenerateUnit(info);

            var sourceText = unit.NormalizeWhitespace(elasticTrivia: true)
                .GetText(Encoding.UTF8);

            ctx.AddSource($"{info!.Symbol.Name}.g.cs", sourceText);
        });
    }

    private static CompilationUnitSyntax GenerateUnit(StructStubGenerationContext? info)
    {
        var modifiers = info!.Syntax.Modifiers;
            
        if (!info.Syntax.HasModifier(SyntaxKind.UnsafeKeyword))
        {
            modifiers = modifiers.Insert(modifiers.IndexOf(SyntaxKind.PartialKeyword), Token(SyntaxKind.UnsafeKeyword));
        }
        
        var baseListElements = GenerateBaseTypes(info).ToList();

        BaseListSyntax? baseList = null;
        if(baseListElements.Count > 0)
        {
            baseList = BaseList(
                    SeparatedList<BaseTypeSyntax>(
                        baseListElements));
        }

        var structDeclaration = StructDeclaration(info.Syntax.Identifier)
            .WithModifiers(modifiers)
            .WithMembers(GenerateStructMembers(info))
            .WithBaseList(baseList)
            .WithAttributeLists(
                List([
                    AttributeFactory.GeneratedCode(),
                    AttributeFactory.SkipLocalsInit()
                ]));

        if(info.Syntax.TypeParameterList != null)
        {
            structDeclaration = structDeclaration.WithTypeParameterList(info.Syntax.TypeParameterList);
        }

        var namespaceDeclaration = NamespaceDeclaration(
                ParseName(info.Symbol.ContainingNamespace.ToDisplayString()))
            .AddMembers(structDeclaration);

        var unit = CompilationUnit()
            .AddMembers(namespaceDeclaration)
            .WithLeadingTrivia(
                TriviaFactory.AutoGeneratedComment(),
                TriviaFactory.NullableEnable());
        return unit;
    }

    /// <summary>
    /// Returns the base types for the generated struct implementation.
    /// </summary>
    private static IEnumerable<SimpleBaseTypeSyntax> GenerateBaseTypes(StructStubGenerationContext ctx)
    {
        IEnumerable<SimpleBaseTypeSyntax> result = [];

        if (ctx.IsComponent)
        {
            result = result.Append(
                SimpleBaseType(
                    ParseTypeName(Constants.ComponentInterfaceFQN)));
        }

        if (ctx.IsExtension)
        {
            result = result.Append(
                SimpleBaseType(
                    ParseTypeName(Constants.ExtensionInterfaceFQN)));
        }

        if (ctx.IsIdProvider)
        {
            result = result.Append(
                SimpleBaseType(
                    ParseTypeName(Constants.IdProviderInterfaceFQN)));
        }

        return result;
    }

    /// <summary>
    /// Returns the members for the struct implementation.
    /// </summary>
    private static SyntaxList<MemberDeclarationSyntax> GenerateStructMembers(StructStubGenerationContext ctx)
    {
        return List([
            ..CreationMembersGenerator.GenerateCreationMembers(ctx), 
            ..CastMembersGenerator.GenerateCastMembers(ctx),
            ..EqualityMembersGenerator.GenerateEqualityMembers(ctx),
            ..ForwardingMembersGenerator.GenerateImplementingTypeMembers(ctx),
            ..NativeMembersGenerator.GenerateNativeMethods(ctx)
        ]);
    }
    
    /// <summary>
    /// Returns the struct generation context for a code gen context.
    /// </summary>
    private static StructStubGenerationContext? GetStructDeclaration(GeneratorAttributeSyntaxContext ctx, CancellationToken cancellationToken)
    {
        var targetNode = (StructDeclarationSyntax)ctx.TargetNode;
        if (ctx.TargetSymbol is not INamedTypeSymbol symbol)
        {
            return null;
        }

        var attribute = ctx.Attributes.Single();

        var isPartial = symbol.GetAttribute(Constants.ApiPartialAttributeFQN) != null;
        
        var library = attribute.NamedArguments.FirstOrDefault(x => x.Key == "Library")
            .Value.Value as string ?? "SampSharp";

        var nativeTypeName = attribute.NamedArguments.FirstOrDefault(x => x.Key == "NativeTypeName")
            .Value.Value as string ?? symbol.Name;

        var wellKnownMarshallerTypes = WellKnownMarshallerTypes.Create(ctx.SemanticModel.Compilation);
        var ctxFactory = new IdentifierStubContextFactory(wellKnownMarshallerTypes);


        var implementingTypes = new List<ImplementingType>();
        AddImplementingTypes(implementingTypes, attribute, [], [], targetNode);

        var isComponent = !isPartial && implementingTypes.Any(x => x.Type.Symbol.ToDisplayString() == Constants.ComponentFQN);
        var isExtension = !isPartial && implementingTypes.Any(x => x.Type.Symbol.ToDisplayString() == Constants.ExtensionFQN);
        var isIdProvider = implementingTypes.Any(x => x.Type.Symbol.ToDisplayString() == Constants.IdProviderFQN);
        // filter methods: partial, non-static, non-generic
        var methods = targetNode.Members
            .OfType<MethodDeclarationSyntax>()
            .Where(x => x.IsPartial() && !x.HasModifier(SyntaxKind.StaticKeyword) && x.TypeParameterList == null)
            .Select(methodDeclaration => ctx.SemanticModel.GetDeclaredSymbol(methodDeclaration, cancellationToken) is { } methodSymbol
                ? (methodDeclaration, methodSymbol)
                : (null, null))
            .Where(x => x.methodSymbol != null)
            .Select(method =>
            {
                var parameters = method.methodSymbol!.Parameters
                    .Select(parameter => ctxFactory.Create(parameter, MarshalDirection.ManagedToUnmanaged))
                    .ToArray();
                
                var returnValueContext = ctxFactory.Create(method.methodSymbol, MarshalDirection.ManagedToUnmanaged);

                if (returnValueContext.Shape != MarshallerShape.None && (method.methodSymbol.ReturnsByRef || method.methodSymbol.ReturnsByRefReadonly))
                {
                    // marshalling return-by-ref not supported.
                    return null;
                }

                return new ApiMethodStubGenerationContext(
                    method.methodDeclaration!,
                    method.methodSymbol, 
                    parameters, 
                    returnValueContext,
                    library,
                    nativeTypeName);
            })
            .Where(x => x != null)
            .ToArray();

        return new StructStubGenerationContext(symbol, targetNode, methods!, implementingTypes.ToArray(), isExtension, isComponent, isIdProvider, library);
    }

    private static void AddImplementingTypes(List<ImplementingType> implementingTypes, AttributeData attribute, DefiniteType[] castPath, List<ITypeSymbol> trace,
        StructDeclarationSyntax structDecl)
    {
        var typesImplementedHere = attribute.ConstructorArguments[0].Values
            .Select(x => (INamedTypeSymbol)x.Value!)
            .ToArray();
    
        foreach (var type in typesImplementedHere)
        {
            TypeSyntax syntax;
            if (type.IsGenericType && structDecl.TypeParameterList != null)
            {
                syntax = GenericName(
                        Identifier(type.Name))
                    .WithTypeArgumentList(
                        TypeArgumentList(
                            SeparatedList<TypeSyntax>(
                                structDecl.TypeParameterList.Parameters.Select(x => IdentifierName(x.Identifier)))));
            }
            else
            {
                syntax = TypeNameGlobal(type);
            }

            var def = new DefiniteType(type, syntax);

            if (implementingTypes.Any(x => x.Type.Symbol.IsSame(type)))
            {
                continue;
            }

            implementingTypes.Add(new ImplementingType(def, [..castPath, def]));
        }

        foreach (var type in typesImplementedHere)
        {
            var nestedAttribute = type.GetAttribute(Constants.ApiAttributeFQN);

            if (nestedAttribute == null)
            {
                continue;
            }
            
            if (trace.Any(x => x.IsSame(type)))
            {
                continue;
            }
            
            trace.Add(type);
            
            var syntax = TypeNameGlobal(type);
            var def = new DefiniteType(type, syntax);

            AddImplementingTypes(implementingTypes, nestedAttribute!, [..castPath, def], trace, structDecl);

        }
    }
}